<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ü–æ—Ä—Ç—Ñ–æ–ª–∏–æ Unity Developer</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
    <!-- Highlight.js -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/glsl.min.js"></script>
    <script>hljs.highlightAll();</script>

</head>
<body>

<header>
    <h1 data-i18n="title">–î–∞–Ω–∏–∏–ª ‚Äî Unity Developer</h1>
    <p data-i18n="subtitle">Middle Unity Developer ‚Ä¢ Game Development ‚Ä¢ C#</p>

    <!-- –ü–µ—Ä–µ–∫–ª—é—á–∞—Ç–µ–ª—å —è–∑—ã–∫–æ–≤ -->
    <div class="lang-select">
        <select onchange="setLang(this.value)">
            <option value="ru">üá∑üá∫ –†—É—Å—Å–∫–∏–π</option>
            <option value="en">üá¨üáß English</option>
            <option value="ua">üá∫üá¶ –£–∫—Ä–∞—ó–Ω—Å—å–∫–∞</option>
            <option value="pl">üáµüá± Polski</option>
        </select>
    </div>
</header>

<!-- üì∏ –§–æ—Ç–æ -->
<section class="portfolio-section">
    <h2 data-i18n="photos_title">–§–æ—Ç–æ –ø—Ä–æ–µ–∫—Ç–æ–≤</h2>
    <h3 data-i18n="photos_sub1">(–§–æ—Ç–æ –º–Ω–æ–≥–∏—Ö –ø—Ä–æ–µ–∫—Ç–æ–≤ –≤ –∫–æ—Ç–æ—Ä—ã—Ö —è –ø—Ä–∏–Ω–∏–º–∞–ª —É—á–∞—Å—Ç–∏–µ –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ, –Ω–µ –±—ã–ª–∏ –Ω–∞–π–¥–µ–Ω—ã)</h3>
    <h3 data-i18n="photos_sub2">–°—É–¥—å–±–∞ –∏–≥—Ä –Ω–µ –∏–∑–≤–µ—Å—Ç–Ω–∞.</h3>
    <div class="portfolio" id="photos">

        <div class="card">
            <img src="2024-0.jpg" alt="">
            <div class="card-content">
                <p data-i18n="photo1">–õ–æ–∫–∞—Ü–∏—è —Å–º–æ–¥–µ–ª–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –º–Ω–æ—é.</p>
            </div>
        </div>

        <div class="card">
            <img src="2024-1.jpg" alt="">
            <div class="card-content">
                <p data-i18n="photo2">–õ–æ–∫–∞—Ü–∏—è —Å–º–æ–¥–µ–ª–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –º–Ω–æ—é.</p>
            </div>
        </div>

        <div class="card">
            <img src="2024-2.jpg" alt="">
            <div class="card-content">
                <p data-i18n="photo3">–õ–æ–∫–∞—Ü–∏—è —Å–º–æ–¥–µ–ª–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –º–Ω–æ—é.</p>
            </div>
        </div>

        <div class="card">
            <img src="2025-1.jpg" alt="">
            <div class="card-content">
                <p data-i18n="photo4">–ú–æ–¥–µ–ª—å –æ—Ä—É–∂–∏—è.</p>
            </div>
        </div>

        <div class="card">
            <img src="2025-2.jpg" alt="">
            <div class="card-content">
                <p data-i18n="photo5">–ú–æ–¥–µ–ª—å –æ—Ä—É–∂–∏—è.</p>
            </div>
        </div>

        <div class="card">
            <img src="2025-3.jpg" alt="">
            <div class="card-content">
                <p data-i18n="photo6">–ú–æ–¥–µ–ª—å –æ—Ä—É–∂–∏—è.</p>
            </div>
        </div>

        <div class="card">
            <img src="2025-4.jpg" alt="">
            <div class="card-content">
                <p data-i18n="photo7">–°—Ü–µ–Ω–∞ –¥–ª—è –∫–∞—Ç—Å—Ü–µ–Ω—ã —Å—é–∂–µ—Ç–Ω–æ–π –∏–≥—Ä—ã.</p>
            </div>
        </div>

        <div class="card">
            <img src="2025-6.jpg" alt="">
            <div class="card-content">
                <p data-i18n="photo8">–ú–æ–¥–µ–ª—å –æ—Ä—É–∂–∏—è.</p>
            </div>
        </div>

        <div class="card">
            <img src="2025-7.jpg" alt="">
            <div class="card-content">
                <p data-i18n="photo9">–ú–æ–¥–µ–ª—å –æ—Ä—É–∂–∏—è.</p>
            </div>
        </div>

        <div class="card">
            <img src="razbor-asseta.jpg" alt="">
            <div class="card-content">
                <p data-i18n="photo10">–°–∫—Ä–∏–Ω—à–æ—Ç –∏–∑ Asseta, —Ä–∞–∑–±–æ—Ä –∫–æ–¥–∞ –∫–æ—Ç–æ—Ä–æ–≥–æ —è –¥–µ–ª–∞–ª.</p>
            </div>
        </div>

        <div class="card">
            <img src="razbor-asseta-1.jpg" alt="">
            <div class="card-content">
                <p data-i18n="photo11">–°–∫—Ä–∏–Ω—à–æ—Ç –∏–∑ Asseta, —Ä–∞–∑–±–æ—Ä –∫–æ–¥–∞ –∫–æ—Ç–æ—Ä–æ–≥–æ —è –¥–µ–ª–∞–ª.</p>
            </div>
        </div>

    </div>
</section>

<!-- üé• –í–∏–¥–µ–æ -->
<section class="portfolio-section">
    <h2 data-i18n="videos_title">–í–∏–¥–µ–æ –ø—Ä–æ–µ–∫—Ç–æ–≤</h2>
    <h3 data-i18n="videos_sub1">(–í–∏–¥–µ–æ –º–Ω–æ–≥–∏—Ö –ø—Ä–æ–µ–∫—Ç–æ–≤ –≤ –∫–æ—Ç–æ—Ä—ã—Ö —è –ø—Ä–∏–Ω–∏–º–∞–ª —É—á–∞—Å—Ç–∏–µ –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ, –Ω–µ –±—ã–ª–∏ –Ω–∞–π–¥–µ–Ω—ã)</h3>
    <h3 data-i18n="videos_sub2">–°—É–¥—å–±–∞ –∏–≥—Ä –Ω–µ –∏–∑–≤–µ—Å—Ç–Ω–∞.</h3>
    <div class="portfolio" id="videos">

        <div class="card">
            <video src="2023-1.mp4" controls></video>
            <div class="card-content">
                <h3>2023</h3>
                <p data-i18n="video1">–í—ã–ø–æ–ª–Ω—è–ª —Ä–æ–ª—å –∫–æ–¥–µ—Ä–∞.</p>
            </div>
        </div>

        <div class="card">
            <video src="2025.mp4" controls></video>
            <div class="card-content">
                <h3>2025</h3>
                <p data-i18n="video2">–í—ã–ø–æ–ª–Ω—è–ª —Ä–æ–ª—å –≥–ª–∞–≤–Ω–æ–≥–æ –∫–æ–¥–µ—Ä–∞.</p>
            </div>
        </div>

        <div class="card">
            <video src="2025-8.mp4" controls></video>
            <div class="card-content">
                <h3>3D Animation</h3>
                <p data-i18n="video3">–°–º–æ–¥–µ–ª–∏—Ä–æ–≤–∞–ª –≥–æ—Ä–æ–¥ –∏ —Å–¥–µ–ª–∞–ª –∞–Ω–∏–º–∞—Ü–∏—é.</p>
            </div>
        </div>

        <div class="card">
            <video src="Euro2024.mp4" controls></video>
            <div class="card-content">
                <h3>2024</h3>
                <p data-i18n="video4">–í—ã–ø–æ–ª–Ω—è–ª —Ä–æ–ª—å –∫–æ–¥–µ—Ä–∞.</p>
            </div>
        </div>

        <div class="card">
            <video src="NewLevelSequence1_411.mp4" controls></video>
            <div class="card-content">
                <h3>3D</h3>
                <p data-i18n="video5">–°–º–æ–¥–µ–ª–∏—Ä–æ–≤–∞–ª –ª–æ–∫–∞—Ü–∏—é.</p>
            </div>
        </div>

        <div class="card">
            <video src="Plinko Game.mp4" controls></video>
            <div class="card-content">
                <h3>2025</h3>
                <p data-i18n="video6">–í—ã–ø–æ–ª–Ω—è–ª —Ä–æ–ª—å –≥–ª–∞–≤–Ω–æ–≥–æ –∫–æ–¥–µ—Ä–∞.</p>
            </div>
        </div>

        <div class="card">
            <video src="Simple Signmon.mp4" controls></video>
            <div class="card-content">
                <h3>2025</h3>
                <p data-i18n="video7">–í—ã–ø–æ–ª–Ω—è–ª —Ä–æ–ª—å –≥–ª–∞–≤–Ω–æ–≥–æ –∫–æ–¥–µ—Ä–∞.</p>
            </div>
        </div>
    </div>
</section>

<!-- üë®‚Äçüíª –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è –∫–æ–¥–∞ -->
<section class="portfolio-section">
    <h2 data-lang="code_title">Code</h2>
    <div class="portfolio">
        <div class="card">
            <div class="card-content">
                <h3>Mini programming language.</h3>
                <pre><code class="language-csharp">
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;

namespace MiniLang
{
    enum TokenType
    {
        Number, String, Identifier,
        Plus, Minus, Star, Slash, Caret,
        LParen, RParen, Comma, Semicolon,
        Equal, DoubleEqual, NotEqual, Less, LessEqual, Greater, GreaterEqual,
        And, Or, Not,
        Assign, Let,
        EOF
    }

    class Token
    {
        public TokenType Type;
        public string Text;
        public Token(TokenType t, string txt) { Type = t; Text = txt; }
        public override string ToString() => $"{Type}:{Text}";
    }

    class Lexer
    {
        private readonly string _s;
        private int _i = 0;
        public Lexer(string s) { _s = s; }

        private char Current => _i < _s.Length ? _s[_i] : '\0';
        private void Next() => _i++;

        public List< Token> Tokenize()
        {
            var tokens = new List< Token>();
            while (_i < _s.Length)
            {
                if (char.IsWhiteSpace(Current)) { Next(); continue; }
                if (Current == '/' && Peek() == '/')
                {
                    while (Current != '\n' && Current != '\0') Next();
                    continue;
                }
                if (char.IsDigit(Current) || (Current == '.' && char.IsDigit(Peek())))
                {
                    var start = _i;
                    while (char.IsDigit(Current) || Current == '.') Next();
                    tokens.Add(new Token(TokenType.Number, _s.Substring(start, _i - start)));
                    continue;
                }
                if (Current == '"' || Current == '\'')
                {
                    var quote = Current; Next();
                    var sb = new StringBuilder();
                    while (Current != quote && Current != '\0')
                    {
                        if (Current == '\\')
                        {
                            Next();
                            if (Current == 'n') { sb.Append('\n'); Next(); }
                            else if (Current == 't') { sb.Append('\t'); Next(); }
                            else { sb.Append(Current); Next(); }
                        }
                        else { sb.Append(Current); Next(); }
                    }
                    if (Current == quote) Next();
                    tokens.Add(new Token(TokenType.String, sb.ToString()));
                    continue;
                }
                if (char.IsLetter(Current) || Current == '_')
                {
                    var start = _i;
                    while (char.IsLetterOrDigit(Current) || Current == '_') Next();
                    var word = _s.Substring(start, _i - start);
                    switch (word)
                    {
                        case "let": tokens.Add(new Token(TokenType.Let, word)); break;
                        case "true": tokens.Add(new Token(TokenType.Identifier, "true")); break;
                        case "false": tokens.Add(new Token(TokenType.Identifier, "false")); break;
                        case "and": tokens.Add(new Token(TokenType.And, "and")); break;
                        case "or": tokens.Add(new Token(TokenType.Or, "or")); break;
                        case "not": tokens.Add(new Token(TokenType.Not, "not")); break;
                        default: tokens.Add(new Token(TokenType.Identifier, word)); break;
                    }
                    continue;
                }
                switch (Current)
                {
                    case '+': tokens.Add(new Token(TokenType.Plus, "+")); Next(); break;
                    case '-': tokens.Add(new Token(TokenType.Minus, "-")); Next(); break;
                    case '*': tokens.Add(new Token(TokenType.Star, "*")); Next(); break;
                    case '/': tokens.Add(new Token(TokenType.Slash, "/")); Next(); break;
                    case '^': tokens.Add(new Token(TokenType.Caret, "^")); Next(); break;
                    case '(': tokens.Add(new Token(TokenType.LParen, "(")); Next(); break;
                    case ')': tokens.Add(new Token(TokenType.RParen, ")")); Next(); break;
                    case ',': tokens.Add(new Token(TokenType.Comma, ",")); Next(); break;
                    case ';': tokens.Add(new Token(TokenType.Semicolon, ";")); Next(); break;
                    case '!':
                        Next();
                        if (Current == '=') { Next(); tokens.Add(new Token(TokenType.NotEqual, "!=")); }
                        else tokens.Add(new Token(TokenType.Not, "!"));
                        break;
                    case '=':
                        Next();
                        if (Current == '=') { Next(); tokens.Add(new Token(TokenType.DoubleEqual, "==")); }
                        else tokens.Add(new Token(TokenType.Assign, "="));
                        break;
                    case '<':
                        Next();
                        if (Current == '=') { Next(); tokens.Add(new Token(TokenType.LessEqual, "<=")); }
                        else tokens.Add(new Token(TokenType.Less, "<"));
                        break;
                    case '>':
                        Next();
                        if (Current == '=') { Next(); tokens.Add(new Token(TokenType.GreaterEqual, ">=")); }
                        else tokens.Add(new Token(TokenType.Greater, ">"));
                        break;
                    case '&':
                        Next();
                        if (Current == '&') { Next(); tokens.Add(new Token(TokenType.And, "&&")); }
                        else tokens.Add(new Token(TokenType.And, "&"));
                        break;
                    case '|':
                        Next();
                        if (Current == '|') { Next(); tokens.Add(new Token(TokenType.Or, "||")); }
                        else tokens.Add(new Token(TokenType.Or, "|"));
                        break;
                    default:
                        throw new Exception($"Unrecognized char: {Current}");
                }
            }
            tokens.Add(new Token(TokenType.EOF, ""));
            return tokens;
        }

        private char Peek() => _i + 1 < _s.Length ? _s[_i + 1] : '\0';
    }

    abstract class Expr { }
    class NumberExpr : Expr { public double Value; public NumberExpr(double v) { Value = v; } }
    class StringExpr : Expr { public string Value; public StringExpr(string v) { Value = v; } }
    class BoolExpr : Expr { public bool Value; public BoolExpr(bool v) { Value = v; } }
    class VariableExpr : Expr { public string Name; public VariableExpr(string n) { Name = n; } }
    class BinaryExpr : Expr { public string Op; public Expr Left, Right; public BinaryExpr(string op, Expr l, Expr r) { Op = op; Left = l; Right = r; } }
    class UnaryExpr : Expr { public string Op; public Expr Right; public UnaryExpr(string op, Expr r) { Op = op; Right = r; } }
    class CallExpr : Expr { public string Name; public List< Expr> Args; public CallExpr(string name, List< Expr> args) { Name = name; Args = args; } }
    class AssignStmt : Expr { public string Name; public Expr Value; public AssignStmt(string name, Expr value) { Name = name; Value = value; } }

    class Parser
    {
        private readonly List< Token> _tokens;
        private int _i = 0;
        private Token Cur => _tokens[_i];
        public Parser(List< Token> tokens) { _tokens = tokens; }

        private Token Eat(TokenType t)
        {
            if (Cur.Type == t) { var tmp = Cur; _i++; return tmp; }
            throw new Exception($"Expected {t}, got {Cur.Type} ({Cur.Text})");
        }

        private bool Match(TokenType t) { if (Cur.Type == t) { _i++; return true; } return false; }

        public Expr ParseTopLevel()
        {
            Expr last = null;
            while (Cur.Type != TokenType.EOF)
            {
                last = ParseStatement();
                if (Cur.Type == TokenType.Semicolon) Match(TokenType.Semicolon);
                else if (Cur.Type != TokenType.EOF) { }
            }
            return last;
        }

        private Expr ParseStatement()
        {
            if (Cur.Type == TokenType.Let)
            {
                Eat(TokenType.Let);
                var id = Eat(TokenType.Identifier).Text;
                Eat(TokenType.Assign);
                var val = ParseExpr();
                return new AssignStmt(id, val);
            }
            return ParseExpr();
        }

        private Expr ParseExpr() => ParseOr();

        private Expr ParseOr()
        {
            var left = ParseAnd();
            while (Cur.Type == TokenType.Or)
            {
                _i++;
                var right = ParseAnd();
                left = new BinaryExpr("or", left, right);
            }
            return left;
        }

        private Expr ParseAnd()
        {
            var left = ParseEquality();
            while (Cur.Type == TokenType.And)
            {
                _i++;
                var right = ParseEquality();
                left = new BinaryExpr("and", left, right);
            }
            return left;
        }

        private Expr ParseEquality()
        {
            var left = ParseComparison();
            while (Cur.Type == TokenType.DoubleEqual || Cur.Type == TokenType.NotEqual)
            {
                _i++;
                var right = ParseComparison();
                left = new BinaryExpr(_tokens[_i-1].Text, left, right);
            }
            return left;
        }

        private Expr ParseComparison()
        {
            var left = ParseTerm();
            while (Cur.Type == TokenType.Less || Cur.Type == TokenType.LessEqual || Cur.Type == TokenType.Greater || Cur.Type == TokenType.GreaterEqual)
            {
                var op = Cur.Text; _i++;
                var right = ParseTerm();
                left = new BinaryExpr(op, left, right);
            }
            return left;
        }

        private Expr ParseTerm()
        {
            var left = ParseFactor();
            while (Cur.Type == TokenType.Plus || Cur.Type == TokenType.Minus)
            {
                var op = Cur.Text; _i++;
                var right = ParseFactor();
                left = new BinaryExpr(op, left, right);
            }
            return left;
        }

        private Expr ParseFactor()
        {
            var left = ParsePower();
            while (Cur.Type == TokenType.Star || Cur.Type == TokenType.Slash)
            {
                var op = Cur.Text; _i++;
                var right = ParsePower();
                left = new BinaryExpr(op, left, right);
            }
            return left;
        }

        private Expr ParsePower()
        {
            var left = ParseUnary();
            while (Cur.Type == TokenType.Caret)
            {
                _i++;
                var right = ParseUnary();
                left = new BinaryExpr("^", left, right);
            }
            return left;
        }

        private Expr ParseUnary()
        {
            if (Cur.Type == TokenType.Minus) { _i++; var r = ParseUnary(); return new UnaryExpr("-", r); }
            if (Cur.Type == TokenType.Not) { _i++; var r = ParseUnary(); return new UnaryExpr("!", r); }
            return ParsePrimary();
        }

        private Expr ParsePrimary()
        {
            if (Cur.Type == TokenType.Number)
            {
                var n = double.Parse(Cur.Text, CultureInfo.InvariantCulture);
                _i++; return new NumberExpr(n);
            }
            if (Cur.Type == TokenType.String)
            {
                var s = Cur.Text; _i++; return new StringExpr(s);
            }
            if (Cur.Type == TokenType.Identifier)
            {
                var name = Cur.Text; _i++;
                if (Cur.Type == TokenType.LParen)
                {
                    _i++;
                    var args = new List< Expr>();
                    if (Cur.Type != TokenType.RParen)
                    {
                        args.Add(ParseExpr());
                        while (Cur.Type == TokenType.Comma) { _i++; args.Add(ParseExpr()); }
                    }
                    Eat(TokenType.RParen);
                    return new CallExpr(name, args);
                }
                if (name == "true") return new BoolExpr(true);
                if (name == "false") return new BoolExpr(false);
                return new VariableExpr(name);
            }
            if (Cur.Type == TokenType.LParen)
            {
                Eat(TokenType.LParen);
                var e = ParseExpr();
                Eat(TokenType.RParen);
                return e;
            }
            throw new Exception($"Unexpected token {Cur.Type} ({Cur.Text})");
        }
    }

    class EvalContext
    {
        public Dictionary< string, object> Variables = new Dictionary< string, object>(StringComparer.OrdinalIgnoreCase);
        public Dictionary< string, Func< List< object>, object>> Builtins = new Dictionary< string, Func< List< object>, object>>(StringComparer.OrdinalIgnoreCase);

        public EvalContext()
        {
            RegisterBuiltins();
        }

        private void RegisterBuiltins()
        {
            Builtins["sin"] = args => Math.Sin(ToNumber(args, 0));
            Builtins["cos"] = args => Math.Cos(ToNumber(args, 0));
            Builtins["tan"] = args => Math.Tan(ToNumber(args, 0));
            Builtins["sqrt"] = args => Math.Sqrt(ToNumber(args, 0));
            Builtins["pow"] = args => Math.Pow(ToNumber(args, 0), ToNumber(args, 1));
            Builtins["abs"] = args => Math.Abs(ToNumber(args, 0));
            Builtins["max"] = args => Math.Max(ToNumber(args, 0), ToNumber(args, 1));
            Builtins["min"] = args => Math.Min(ToNumber(args, 0), ToNumber(args, 1));
            Builtins["round"] = args => Math.Round(ToNumber(args, 0));
            Builtins["concat"] = args => string.Concat(args.Select(a => ToStringVal(a)));
            Builtins["len"] = args => (double)ToStringVal(args[0]).Length;
            Builtins["substr"] = args =>
            {
                var s = ToStringVal(args[0]);
                var start = (int)ToNumber(args, 1);
                if (args.Count == 2) return s.Substring(Math.Clamp(start, 0, s.Length));
                var len = (int)ToNumber(args, 2);
                start = Math.Clamp(start, 0, s.Length);
                var endLen = Math.Clamp(len, 0, s.Length - start);
                return s.Substring(start, endLen);
            };
            Builtins["upper"] = args => ToStringVal(args[0]).ToUpperInvariant();
            Builtins["lower"] = args => ToStringVal(args[0]).ToLowerInvariant();
            Builtins["trim"] = args => ToStringVal(args[0]).Trim();
            Builtins["if"] = args =>
            {
                var cond = ToBool(args[0]);
                return cond ? args[1] : (args.Count > 2 ? args[2] : null);
            };
            Builtins["print"] = args =>
            {
                foreach (var a in args) Console.Write(ToStringVal(a) + " ");
                Console.WriteLine();
                return null;
            };
        }

        private static string ToStringVal(object o) => o switch
        {
            null => "",
            double d when d % 1 == 0 => ((long)d).ToString(),
            double d => d.ToString(CultureInfo.InvariantCulture),
            bool b => b ? "true" : "false",
            string s => s,
            _ => o.ToString()
        };

        private static double ToNumber(List< object> args, int idx)
        {
            if (idx >= args.Count) throw new Exception("Not enough arguments");
            return ConvertToNumber(args[idx]);
        }

        private static double ConvertToNumber(object o)
        {
            if (o is double d) return d;
            if (o is bool b) return b ? 1.0 : 0.0;
            if (o is string s && double.TryParse(s, NumberStyles.Any, CultureInfo.InvariantCulture, out var v)) return v;
            throw new Exception($"Cannot convert to number: {o}");
        }

        private static bool ToBool(object o)
        {
            if (o is bool b) return b;
            if (o is double d) return Math.Abs(d) > 1e-12;
            if (o is string s) return !string.IsNullOrEmpty(s);
            return o != null;
        }

        public object Evaluate(Expr node)
        {
            switch (node)
            {
                case NumberExpr n: return n.Value;
                case StringExpr s: return s.Value;
                case BoolExpr b: return b.Value;
                case VariableExpr v:
                    if (Variables.TryGetValue(v.Name, out var valVar)) return valVar;
                    throw new Exception($"Undefined variable '{v.Name}'");
                case AssignStmt asn:
                    var assignedValue = Evaluate(asn.Value);
                    Variables[asn.Name] = assignedValue;
                    return assignedValue;
                case UnaryExpr u:
                    var r = Evaluate(u.Right);
                    if (u.Op == "-") return -ConvertToNumber(r);
                    if (u.Op == "!") return !ToBool(r);
                    throw new Exception($"Unknown unary op {u.Op}");
                case BinaryExpr b:
                    return EvalBinary(b);
                case CallExpr c:
                    return EvalCall(c);
                default:
                    throw new Exception("Unknown node");
            }
        }


        private object EvalCall(CallExpr c)
        {
            var args = c.Args.Select(a => Evaluate(a)).ToList();
            if (Builtins.TryGetValue(c.Name, out var fn))
            {
                return fn(args);
            }
            throw new Exception($"Unknown function '{c.Name}'");
        }

        private object EvalBinary(BinaryExpr b)
        {
            if (b.Op == "and")
            {
                var left = Evaluate(b.Left);
                if (!ToBool(left)) return false;
                var right = Evaluate(b.Right);
                return ToBool(right);
            }
            if (b.Op == "or")
            {
                var left = Evaluate(b.Left);
                if (ToBool(left)) return true;
                var right = Evaluate(b.Right);
                return ToBool(right);
            }

            var l = Evaluate(b.Left);
            var r = Evaluate(b.Right);

            if (b.Op == "==") return AreEqual(l, r);
            if (b.Op == "!=") return !AreEqual(l, r);
            if (b.Op == "<" || b.Op == ">" || b.Op == "<=" || b.Op == ">=")
            {
                try
                {
                    var ln = ConvertToNumber(l);
                    var rn = ConvertToNumber(r);
                    return b.Op switch
                    {
                        "<" => ln < rn,
                        "<=" => ln <= rn,
                        ">" => ln > rn,
                        ">=" => ln >= rn,
                        _ => throw new Exception("Unreachable")
                    };
                }
                catch
                {
                    var ls = l?.ToString() ?? "";
                    var rs = r?.ToString() ?? "";
                    var cmp = string.Compare(ls, rs, StringComparison.Ordinal);
                    return b.Op switch
                    {
                        "<" => cmp < 0,
                        "<=" => cmp <= 0,
                        ">" => cmp > 0,
                        ">=" => cmp >= 0,
                        _ => throw new Exception("Unreachable")
                    };
                }
            }

            if (b.Op == "+")
            {
                if (l is string || r is string) return (l?.ToString() ?? "") + (r?.ToString() ?? "");
                return ConvertToNumber(l) + ConvertToNumber(r);
            }
            if (b.Op == "-") return ConvertToNumber(l) - ConvertToNumber(r);
            if (b.Op == "*") return ConvertToNumber(l) * ConvertToNumber(r);
            if (b.Op == "/") return ConvertToNumber(l) / ConvertToNumber(r);
            if (b.Op == "^") return Math.Pow(ConvertToNumber(l), ConvertToNumber(r));

            throw new Exception($"Unknown binary op {b.Op}");
        }

        private static bool AreEqual(object a, object b)
        {
            if (a == null && b == null) return true;
            if (a == null || b == null) return false;
            if (a is double da && b is double db) return Math.Abs(da - db) < 1e-12;
            if (a is bool ba && b is bool bb) return ba == bb;
            return a.ToString() == b.ToString();
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Console.OutputEncoding = System.Text.Encoding.UTF8;
            Console.WriteLine("MiniLang REPL ‚Äî –≤—ã—Ä–∞–∂–µ–Ω–∏—è —Å math, logic, text functions.");
            var ctx = new EvalContext();
            while (true)
            {
                Console.Write("> ");
                var line = Console.ReadLine();
                if (line == null) break;
                if (line.Trim().ToLowerInvariant() == "exit") break;
                if (line.Trim() == "") continue;

                try
                {
                    var lex = new Lexer(line);
                    var tokens = lex.Tokenize();
                    var parser = new Parser(tokens);
                    var expr = parser.ParseTopLevel();
                    var res = ctx.Evaluate(expr);
                    if (res != null)
                    {
                        if (res is double d) Console.WriteLine(d % 1 == 0 ? ((long)d).ToString() : d.ToString(CultureInfo.InvariantCulture));
                        else Console.WriteLine(res);
                    }
                }
                catch (Exception ex)
                {
                    Console.ForegroundColor = ConsoleColor.Red;
                    Console.WriteLine("Error: " + ex.Message);
                    Console.ResetColor();
                }
            }
        }
    }
}

                </code></pre>
            </div>
        </div>

        <div class="card">
            <div class="card-content">
                <h3>Unity PlayerController</h3>
                <pre><code class="language-hlsl">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

[RequireComponent(typeof(CharacterController))]
public class PlayerController : MonoBehaviour
{
    public float walkSpeed = 5.0f;
    public float sneakSpeed = 2.5f;
    public float runSpeed = 8.0f;
    public float crouchWalkSpeed = 3.5f;
    public float crouchRunSpeed = 6.5f;
    public float crouchSneakSpeed = 1f;
    public float jumpSpeed = 6.0f;

    public bool limitDiagonalSpeed = true;
    public bool toggleRun = false;
    public bool toggleSneak = false;
    public bool airControl = true;
    public bool firstPerson = false;
    public bool crouching = false;

    public float gravity = 10.0f;
    public float fallingDamageLimit = 10.0f;

    private Vector3 moveDirection;

    private bool grounded;
    private CharacterController controller;
    private Transform myTransform;
    private float speed;
    private RaycastHit hit;
    private float fallStartLevel;
    private bool falling;
	private bool punching;
    private bool playerControl;
    private Animator anim;


    void Start()
    {
        moveDirection = Vector3.zero;
        grounded = false;
        playerControl = false;
        controller = GetComponent< CharacterController>();
        myTransform = transform;
        speed = walkSpeed;
        anim = GetComponent< Animator>();
    }

    private void FixedUpdate()
    {
        float inputX = Input.GetAxis("Horizontal");
        float inputY = Input.GetAxis("Vertical");
        float inputModifyFactor = (inputX != 0.0f && inputY != 0.0f && limitDiagonalSpeed) ? 0.6701f : 1.0f;

        anim.SetFloat("BlendX", (inputX * 2));
        anim.SetFloat("BlendY", (inputY * 2));
        anim.SetBool("Walking", (anim.GetFloat("BlendX") != 0 || anim.GetFloat("BlendY") != 0));

		anim.SetBool("Punching", Input.GetButton("Fire1"));

        if (grounded)
        {

            if (falling)
            {
                falling = false;
                if (myTransform.position.y < (fallStartLevel - fallingDamageLimit))
                {
                    FallingDamageAlert(fallStartLevel - myTransform.position.y);
                }
            }

            if (!toggleRun)
            {
                bool running = Input.GetButton("Run");
                speed = running ? runSpeed : walkSpeed;
                anim.SetBool("Running", running);
            }

            else
            {
                anim.SetBool("Running", true);
            }

            if (!toggleSneak)
            {
                bool sneaking = Input.GetButton("Sneak");
                speed = sneaking ? sneakSpeed : speed;
                anim.SetBool("Sneaking", sneaking);
            }

            if (crouching)
            {
                speed = Input.GetButton("Run") ? crouchRunSpeed : crouchWalkSpeed;
                speed = Input.GetButton("Sneak") ? crouchSneakSpeed : speed;


            }

            moveDirection = new Vector3(inputX * inputModifyFactor, 0, inputY * inputModifyFactor);
            moveDirection = myTransform.TransformDirection(moveDirection) * speed;

            if (!Input.GetButton("Jump"))
            {
                anim.SetBool("Jump", false);
            }
            else
            {
                moveDirection.y = jumpSpeed;

                anim.SetBool("Jump", true);
            }
        }
        else
        {
            if (!falling)
            {
                falling = true;
                fallStartLevel = myTransform.position.y;
            }

            if (airControl && playerControl)
            {
                moveDirection.x = inputX * speed * inputModifyFactor;
                moveDirection.z = inputY * speed * inputModifyFactor;
                moveDirection = myTransform.TransformDirection(moveDirection);
            }
        }

        grounded = (controller.Move(moveDirection * Time.deltaTime) & CollisionFlags.Below) != 0;
        moveDirection.y -= gravity * Time.deltaTime;


    }

    void Update()
    {
        if (toggleRun && grounded && Input.GetButtonDown("Run"))
            speed = (speed == walkSpeed ? runSpeed : walkSpeed);

        if (Input.GetButtonUp("Crouch"))
        {
            crouching = !crouching;
            anim.SetBool("Crouch", crouching);
        }
    }

    void OnControllerColliderHit(ControllerColliderHit hit)
    {
    }

    void FallingDamageAlert(float fallDistance)
    {
        print("Ouch! Fell " + fallDistance + " units!");
    }
}

</code></pre>

            </div>
        </div>
    </div>
</section>


<!-- üîó –ü–æ–ª–µ–∑–Ω—ã–µ —Å—Å—ã–ª–∫–∏ -->
<section class="links">
    <h2 data-i18n="links_title">–ü–æ–ª–µ–∑–Ω—ã–µ —Å—Å—ã–ª–∫–∏</h2>
    <div class="social-links">
        <a href="https://t.me/Seals_GameDev" target="_blank" class="tg"><i class="fa-brands fa-telegram"></i></a>
    </div>
</section>

<footer>
    ¬© 2025 <span data-i18n="name">–î–∞–Ω–∏–∏–ª</span> | Unity Developer
</footer>

<!-- –∫–∞—Å—Ç–æ–º–Ω—ã–µ –∫—É—Ä—Å–æ—Ä—ã -->
<div class="cursor" id="cursor"></div>
<div class="cursor cursor-small" id="cursorSmall"></div>

<script src="cursor.js"></script>
<script src="translations.js"></script>
</body>
</html>
